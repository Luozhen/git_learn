## 2017年7月14日 星期五

昨天提交代码时，发生了一桩git提交diverge 拒绝的错误。于是痛定下痛决定好好学习git相关提交代码与冲突。

首先我们要明确的是，git算是一个小型的文件系统，在这个文件系统下，git为每个文件新产生的版本拍一个快照。这个时候也许你会问，那么git岂不是会很慢，git开发大牛也想到了这个问题，他给出的解决方法是，如果文件不进行更新，那么会新建一个指针指向原来的版本。

盗用git book上的图。。。。之前的代码版本管理，像CSV是如下这样

![img](https://git-scm.com/book/en/v2/images/deltas.png)

大概就是下面这个意思。是不是很清楚？不清楚稍后再回来说说

![img](https://git-scm.com/book/en/v2/images/snapshots.png)

其中有一点需要理解的是git 的每一个版本都是对当前git库所有文件的快照，git不参与文件的整理工作，而是协助开发人员管理这些版本，以便个人或多人协作完成项目的便捷。

比如说，在没有版本管理工具的年代，人们是对一个文件有修改了，就新建一个文件，重命名文件名并以年月日版本号来标注，这样看似比较好，但是你完全不可以比较两个版本之间的差异，虽然有文本编辑器的对比差异的协作，但是人为很难记清楚哪个版本修改了什么，并且当个人文件夹的同一个文件“不同版本”很多时，往往会带来人为筛选的时间开销。所以现在git能很方便的帮助我们管理这些版本，并且我们不需要对文件进行新建而导致文件夹文件巨多。

git所谓的强大，更体现在在同一个项目中多人协作井然有序。

我昨天遇到的冲突，也是在多人协作中经常遇到的问题。一般情况下，项目版本都放在公司或github共有库（即远端库）中。每个人的本机通过ssh连接远端库，利用git clone命令将远端库拷贝到自己的本机上，然后每个人在自己的本机进行自己功能的开发，开发进行到一定程度（一般是指在所开发功能可以上线或者对原来版本的修改，并本机测试通过的情况下）就会将自己的代码提交到远端库中，然后项目成功运行上线。

以上说的较为笼统，涉及到许多问题的理解。以下我来进行详细说明。

首先，每个人都对远端库有一个拷贝，这个拷贝是对远端库的完全复制，当然也包括git所记录的远端库中版本数据。

在我们更深入讲解之前，首先需要搞清楚git的三个概念。这三个概念有助于日后灵活运用git。

这三个概念是工作区、暂存区和git仓库。如下图：

![img](https://git-scm.com/book/en/v2/images/areas.png)

- 其中工作区就是你自己在本地对文件进行修改的地方。
- 暂存区是git在下次提交版本时所依据的地方，这里面记录着当前添加的文件信息。
- git仓库是保存git版本的地方，它是git的核心。虽然暂存区是存储在git版本库中，但是我打算把它们合并来讲，而是将它们分开，这样有助于理解。

工作区可以看作就是我们存放项目的目录，我们在这个目录中对我们所需要修改的地方进行code，暂存区是将文件快照暂时存储的地方，等待git commit命令后，git会找到暂存区中的文件，并把这些文件快照永久性的存储在git仓库中。

理解了这三个概念后，我们开始理解master分支。一般情况下，在一个目录中，我们使用git init命令后，git就会在该目录下新建一个master目录，这个master目录在多人协作某一个项目时尤其重要，因为一般情况下，master分支称为主分支，人们尽量不要自己修改主分支，只有在自己的项目功能需要添加到主分支时才进行合并。这里涉及到了许多git名词，不太懂没关系，我这就慢慢展开讲解。这就相当于一个项目是一个完整并慢慢成型的木匠作品，一开始该作品有个大致框架，但是每个人需要基于这个框架在合理的地方进行工作。比如说，四个人需要共同完成一个大象的作品，该大象的身体以及制作大小已经定下，需求当然是需要制作成大象的模样，其框架耳朵、鼻子、象鼻、四肢等长得如何并没有完全定下来。分别由四个人来完成，那么这四个人是直接在大象成品上修改么？假设我们的大象成品是要直接拿去拍卖的，那么当然不是，因为每个人完成之后还需要测试，看是否符合大象契合。如果直接在大象成品上修改，那么每个人在修改成品时，那会带来每个人都想独有成品模型，直接工作而导致的工作混乱。那么解决方法是是什么呢？就是每个人都有一个大致的大象身体的副本，并在这个副本上进行自己功能的工作，工作差不多的时候，准备在成品上添加自己已经修改好的功能时，需要看看其他人是否也完成他们自己功能，并在功能交界处商讨处理。

以上这个过程大概就是我们所说的多人协作项目同一个项目的过程。其中git master 分支可以看作是大象的身体，我们不要轻易本地在主分支上进行修改，不然会引起多人一起协作的冲突，这个冲突尤其是在多人都需要对同一个文件进行修改的需求上。每次自己改完，另外一个人之后也改动，却又与自己不适配。那么项目进程会因为这些冲突而大大降低。所以，git的思想是，每个人在克隆远端分支后，在本地新建自己的分支，并在自己的分支上code。等到完成后，则将其与master分支合并，这个合并的过程是将master上自己那块代码添加进去，如果自己有修改本来是master上的文件，那么会产生冲突，需要解决该文件的哪一个版本保留下来，解决之后再添加即可。

以上本地的所有过程都是在自己机子上的改动，只有需要合并时才利用网络，所以git的另一个亮点就是每个人在自己工作机子上工作，工作不受网络影响。

之前涉及到分支的概念，那么现在我们来讲讲。

首先我们要先讲讲master、head的概念。因为git每次新建版本都是对文件的一次快照，master、head只是在快照历史线上的两个指针，head总是指向当前最新提交的版本，master是一开始初始化git版本库时所创建的分支，其实也是一个指针，指向当前最新版本。这个版本保留项目大致框架。所以依照master的由来，分支也只是指向版本的指针。

git可以在当前工作分支的地方随时新建分支，并且因为创建分支仅仅只是创建一个指针，所以极为方便。那么也就是说，如果在当前master分支上创建一个cherish分支，那么仅仅只是在当前版本上添加一个指针，该指针指向master所指向的版本。那么如果切换到cherish分支，并在该分支上提交版本，也即cherish分支指针指向新的版本，但是master分支不变，由于head的字面意思，此时head也指向当前cherish分支所指向的最新版本。

所以之前的diverge报错，拒绝上传是因何而起，大致可以略知一二了。产生之由是由于线上master分支在版本AA之后因为其他人更改了某文件file并新提交一个版本BB，而我本地master也恰恰在版本AA之后更改了该文件file，也提交了新版本CC。然后在我需要将本地master分支推到远端主分支时，因为两个主分支从AA开始不一样，报diverge错也就不奇怪了。如下

所需要做的可以有两种方式，第一种就是使用merge进行合并，git merge origin/master

```
... o ---- o ---- A ---- B  origin/master (upstream work)
                   \
                    C  master (your work)
```

第二种方法是rebase进行合并，git rebase origin/master

```
... o ---- o ---- A ---- B  origin/master (upstream work)
                   \      \
                    C ---- M  master (your work)
```

第三种方式即先将远端分支pull下来，然后再人为解决冲突后重新提交版本。

```
... o ---- o ---- A ---- B  origin/master (upstream work)
                          \
                           C'  master (your work)
```